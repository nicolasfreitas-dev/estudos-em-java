package javacore.Minterfaces.domain;

// INTERFACES NO INICIO FORAM CRIADAS PARA SEREM CONTRATOS COM REGRAS PARA SEREM SEGUIDAS,
// POIS DEVERIAM OBRIGATORIAMENTE TER CLASSES ABSTRATAS DENTRO DELAS, OU SEJA,
// AS CLASSES QUE IMPLEMENTASSEM ESSA INTERFACE DEVERIAM SER OBRIGADAS A IMPLEMENTAR TAMBÉM AS CLASSES ABSTRATAS QUE ELA POSSUÍA
// DE ACORDO COM AS REGRAS DE USO DE CLASSES ABSTRATAS.
// ISSO MUDOU A PARTIR DO JAVA 8, QUANDO PASSOU A SER POSSÍVEL CRIAR CLASSES CONCRETAS DENTRO DE INTERFACES.

// A PARTIR DO JAVA 8, AO UTILIZAR "DEFAULT" CONSEGUIMOS CRIAR UMA
// METODO CONCRETO DENTRO DA INTERFACE QUE NÃO SEGUE A OBRIGATORIEDADE
// DE IMPLEMENTAÇÃO DAS CLASSES ABSTRATAS EM CLASSES QUE IMPLEMENTAREM ESTA INTERFACE.

// AO SOBRESCREVER METODOS NÃO SE DEVE UTILIZAR UM MODIFICADOR DE ACESSO MAIS RESTRITIVO NO METODO SOBRESCRITO
// PRIVATE -> DEFAULT -> PROTECTED -> PUBLIC
// ORDEM DE MAIS RESTRITIVO -> MENOS RESTRITIVO OU "MAIS GERAL"

// **ATRIBUTOS EM INTERFACES**
// TODOS OS ATRIBUTOS EM UMA INTERFACES SÃO CONSTANTES, OU SEJA, PUBLIC STATIC FINAL É REDUNDANTE PODENDO SER OMITIDO

// **METODOS ESTATICOS EM INTERFACES**
// A PARTIR DO JAVA 8, PODEMOS CRIAR METODOS ESTÁTICOS, E COMO SÃO ESTÁTICOS NUNCA SERÃO SOBRESCRITOS PELA CLASSE QUE ESTIVER
// IMPLEMENTANDO ESTA INTERFACE.
// PODEMOS CHAMAR METODOS ESTATICOS DIRETAMENTE PELA INTERFACE OU PELO OBJETO QUE IMPLEMENTOU A INTERFACE
// INDEPENDENTE DE ESTAREM NA MESMA HIERARQUIA,
// AO CHAMARMOS VÃO HAVER DUAS SAIDAS DISTINTAS COMO NO EXEMPLO DO METODO "retrieveMaxDataSize()".

public interface DataLoader {
    public static final int MAX_DATA_SIZE = 10;

    // POR PADRÃO, NAS INTERFACES DO JAVA, TODOS OS MÉTODOS SÃO PUBLIC ABSTRACT,
    // SENDO POSSÍVEL OMITIR ESSAS DIRETIVAS COMO NO EXEMPLO ABAIXO

    void load();

    default void checkPermission() {
        System.out.println("Fazendo checagem de permissões");
    }

    public static void retrieveMaxDataSize() {
        System.out.println("Dentro de retrieveMaxDataSize na interface");
    }
}

